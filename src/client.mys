from tcp.client import Client as TcpClient

@enum(u8)
class _OpCode:
    Continuation = 0
    Text = 1
    Binary = 2
    Close = 8
    Ping = 9
    Pong = 10

@trait
class Handler:

    def on_binary(self, data: bytes):
        """Called when a binary message has been received from the server.

        This method is called from the websocket reader fiber.

        """

    def on_text(self, data: string):
        """Called when a text message has been received from the server.

        This method is called from the websocket reader fiber.

        """

class _DefaultHandler(Handler):
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self,
                 binary_queue: Queue[bytes],
                 text_queue: Queue[string]):
        self._binary_queue = binary_queue
        self._text_queue = text_queue

    def on_binary(self, data: bytes):
        self._binary_queue.put(data)

    def on_text(self, data: string):
        self._text_queue.put(data)

class _ReaderFiber(Fiber):
    _tcp_client: TcpClient
    _header: bytes
    _handler: Handler
    _data_op_code: _OpCode
    _data: bytes
    _header: bytes

    def __init__(self):
        self._data = None
        self._header = bytes(16)

    def _read_frame(self) -> (_OpCode, bytes):
        self._tcp_client.read_into(self._header, 0, 2)
        op_code = _OpCode(self._header)
        data_size = self._header[1] & ~INET_HTTP_WEBSOCKET_MASK

        if data_size == 126:
            self._tcp_client.read_into(self._header, 2, 2)
            data_size = (self._header[2] << 8 | self._header[3])
        elif data_size == 127:
            self._tcp_client.read_into(self._header, 2, 8)
            data_size = ((self._header[6] << 24)
                         | (self._header[7] << 16)
                         | (self._header[8] << 8)
                         | self._header[9])

        data = self._tcp_client.read(data_size)

        return op_code, data

    def _handle_close(self):
        print("Close.")

    def _handle_ping(self):
        print("Ping.")

    def _handle_pong(self):
        print("Pong.")

    def _handle_data(self, op_code: _OpCode, data: bytes):
        if self._data is None:
            self._data_op_code = op_code
            self._data = data
        elif op_code == _OpCode.Continuation:
            self._data += data
        else:
            self._data = None
            return

        if not frame.fin:
            return

        match self._data_op_code:
            case _OpCode.Text:
                self._handler.on_text(string(self._data))
            case _OpCode.Binary:
                self._handler.on_binary(self._data)

    def run(self):
        while True:
            op_code, data = self._read_frame()

            match op_code:
                case _OpCode.Close:
                    self._handle_close()
                case _OpCode.Ping:
                    self._handle_ping()
                case _OpCode.Pong:
                    self._handle_pong()
                case _:
                    self._handle_data(op_code, data)

class Client:
    _tcp_client: TcpClient
    _header: bytes
    _reader_fiber: _ReaderFiber
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self, handler: Handler = None):
        if handler is None:
            self._binary_queue = Queue[bytes]()
            self._text_queue = Queue[string]()
            handler = _DefaultHandler(self._binary_queue, self._text_queue)
        else:
            self._binary_queue = None
            self._text_queue = None

        self._tcp_client = TcpClient()
        self._header = bytes(16)
        self._reader_fiber = _ReaderFiber(handler)

    def connect(self, uri: string):
        """Connect to given server.

        """

        self._tcp_client.write(f"GET {path} HTTP/1.1\r\n"
                               f"Host: {host}\r\n"
                               "Upgrade: WebSocket\r\n"
                               "Connection: Upgrade\r\n"
                               "Origin: MysWebSocketClient\r\n"
                               "\r\n".to_utf8())
        line = self._read_line()

        if line != "HTTP/1.1 101":
            raise WebsocketError("Connection failed.")

        while self._read_line() != "":
            pass

    def disconnect(self):
        """Disconnect from the server.

        """

        self._tcp_client.disconnect()

    def _send(self, data: bytes, op_code: _OpCode):
        if not self._connected:
            raise ConnectionClosedError()

        header_size = 2
        data_size = len(data)
        self._header[0] = (INET_HTTP_WEBSOCKET_FIN | op_code)

        if data_size < 126:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | data_size)
        elif data_size < 65536:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | 126)
            self._header[2] = ((data_size >> 8) & 0xff)
            self._header[3] = ((data_size >> 0) & 0xff)
            header_size += 2
        else:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | 127)
            self._header[2] = 0
            self._header[3] = 0
            self._header[4] = 0
            self._header[5] = 0
            self._header[6] = ((data_size >> 24) & 0xff)
            self._header[7] = ((data_size >> 16) & 0xff)
            self._header[8] = ((data_size >>  8) & 0xff)
            self._header[9] = ((data_size >>  0) & 0xff)
            header_size += 8

        header[header_size + 0] = 0
        header[header_size + 1] = 0
        header[header_size + 2] = 0
        header[header_size + 3] = 0
        header_size += 4

        self._write_lock.acquire()
        self._tcp_client.write_from(self._header, 0, header_size)
        self._tcp_client.write_from(data, 0, data_size)
        self._write_lock.release()

    def send_binary(self, data: bytes):
        """Send given data to the server as a binary message.

        This is a blocking call.

        Raises an error if disconnected.

        """

        self._send(data, _OpCode.Binary)

    def send_text(self, data: string):
        """Send given data to the server as a text message.

        This is a blocking call.

        Raises an error if disconnected.

        """

        self._send(data.to_utf8(), _OpCode.Text)

    def receive_binary(self) -> bytes:
        """Receive a binary message to the server. This method can only be
        used if no handler was given to __init__().

        This is a blocking call.

        Raises an error if disconnected.

        """

        message = self._binary_queue.get()

        if message is None:
            raise ConnectionClosedError()

        return message

    def receive_text(self) -> string:
        """Receive a text message to the server. This method can only be used
        if no handler was given to __init__().

        This is a blocking call.

        Raises an error if disconnected.

        """

        message = self._text_queue.get()

        if message is None:
            raise ConnectionClosedError()

        return message
