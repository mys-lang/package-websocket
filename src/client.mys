from tcp.client import Client as TcpClient

@enum(u8)
class _OpCode:
    Continuation = 0
    Text = 1
    Binary = 2
    Close = 8
    Ping = 9
    Pong = 10

@trait
class Handler:

    def on_binary(self, data: bytes):
        """Called when a binary message has been received from the server.

        This method is called from the websocket reader fiber.

        """

    def on_text(self, data: string):
        """Called when a text message has been received from the server.

        This method is called from the websocket reader fiber.

        """

class DefaultHandler(Handler):
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self,
                 binary_queue: Queue[bytes],
                 text_queue: Queue[string]):
        self._binary_queue = binary_queue
        self._text_queue = text_queue

    def on_binary(self, data: bytes):
        self._binary_queue.put(data)

    def on_text(self, data: string):
        self._text_queue.put(data)

class ReaderFiber(Fiber):
    _tcp_client: TcpClient
    _header: bytes
    _handler: Handler

    def _read_frame(self):
        self._tcp_client.read_into(self._header, 0, 2)
        frame_type = FrameType(self._header)
        data_size = self._header[1] & ~INET_HTTP_WEBSOCKET_MASK

        if data_size == 126:
            self._tcp_client.read_into(self._header, 2, 2)
            data_size = (self._header[2] << 8 | self._header[3])
        elif data_size == 127:
            self._tcp_client.read_into(self._header, 2, 8)
            data_size = ((self._header[6] << 24)
                         | (self._header[7] << 16)
                         | (self._header[8] << 8)
                         | self._header[9])
        data = self._tcp_client.read(data_size)

    def _handle_ping(self, data: bytes):
        pass

    def _handle_pong(self, data: bytes):
        pass

    def _handle_text(self, data: bytes):
        self._handler.on_message(data)

    def _handle_binary(self, data: bytes):
        self._handler.on_message(data)

    def run(self):
        while True:
            type, data = self._read_message()

            match type:
                case FrameType.Ping:
                    self._handle_ping(data)
                case FrameType.Pong:
                    self._handle_pong(data)
                case FrameType.Text:
                    self._handle_text(data)
                case FrameType.Binary:
                    self._handle_binary(data)

class Client:
    _tcp_client: TcpClient
    _header: bytes
    _reader_fiber: ReaderFiber
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self, handler: Handler = None):
        if handler is None:
            self._binary_queue = Queue[bytes]()
            self._text_queue = Queue[string]()
            handler = DefaultHandler(self._binary_queue, self._text_queue)
        else:
            self._binary_queue = None
            self._text_queue = None

        self._tcp_client = TcpClient()
        self._header = bytes(16)
        self._reader_fiber = ReaderFiber(handler)

    def connect(self, uri: string):
        """Connect to given server.

        """

        self._tcp_client.write(f"GET {path} HTTP/1.1\r\n"
                               f"Host: {host}\r\n"
                               "Upgrade: WebSocket\r\n"
                               "Connection: Upgrade\r\n"
                               "Origin: MysWebSocketClient\r\n"
                               "\r\n".to_utf8())
        line = self._read_line()

        if line != "HTTP/1.1 101":
            raise WebsocketError("Connection failed.")

        while self._read_line() != "":
            pass

    def disconnect(self):
        self._tcp_client.disconnect()

    def _send(self, data: bytes, type: FrameType):
        if not self._connected:
            raise ConnectionClosedError()

        header_size = 2
        data_size = len(data)
        self._header[0] = (INET_HTTP_WEBSOCKET_FIN | type)

        if data_size < 126:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | data_size)
        elif data_size < 65536:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | 126)
            self._header[2] = ((data_size >> 8) & 0xff)
            self._header[3] = ((data_size >> 0) & 0xff)
            header_size += 2
        else:
            self._header[1] = (INET_HTTP_WEBSOCKET_MASK | 127)
            self._header[2] = 0
            self._header[3] = 0
            self._header[4] = 0
            self._header[5] = 0
            self._header[6] = ((data_size >> 24) & 0xff)
            self._header[7] = ((data_size >> 16) & 0xff)
            self._header[8] = ((data_size >>  8) & 0xff)
            self._header[9] = ((data_size >>  0) & 0xff)
            header_size += 8

        header[header_size + 0] = 0
        header[header_size + 1] = 0
        header[header_size + 2] = 0
        header[header_size + 3] = 0
        header_size += 4

        self._write_lock.acquire()
        self._tcp_client.write_from(self._header, 0, header_size)
        self._tcp_client.write_from(data, 0, data_size)
        self._write_lock.release()

    def send_binary(self, data: bytes):
        """Send given data to the server as a binary message.

        This is a blocking call.

        Raises an error if disconnected.

        """

        self._send(data, FrameType.Binary)

    def send_text(self, data: string):
        """Send given data to the server as a text message.

        This is a blocking call.

        Raises an error if disconnected.

        """

        self._send(data.to_utf8(), FrameType.Text)

    def recv_binary(self) -> bytes:
        """Receive a binary message to the server. This method can only be
        used if no handler was given to __init__().

        This is a blocking call.

        Raises an error if disconnected.

        """

        message = self._binary_queue.get()

        if message is None:
            raise ConnectionClosedError()

        return message

    def recv_text(self) -> string:
        """Receive a text message to the server. This method can only be used
        if no handler was given to __init__().

        This is a blocking call.

        Raises an error if disconnected.

        """

        message = self._text_queue.get()

        if message is None:
            raise ConnectionClosedError()

        return message
