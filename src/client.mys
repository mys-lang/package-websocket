from fiber import Fiber
from fiber import Queue
from net.tcp.client import Client as TcpClient
from .errors import WebsocketError
from base64 import encode as base64_encode
from random.pseudo import randbytes

@enum(u8)
class _OpCode:
    Continuation = 0
    Text = 1
    Binary = 2
    Close = 8
    Ping = 9
    Pong = 10

HEADER_MASK: u8 = 0x80
HEADER_FIN: u8 = 0x80

@trait
class Handler:
    """All methods are called from the client's reader fiber.

    """

    def on_binary(self, data: bytes):
        """Called when a binary message has been received from the server.

        """

    def on_text(self, data: string):
        """Called when a text message has been received from the server.

        """

class _DefaultHandler(Handler):
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self, binary_queue: Queue[bytes], text_queue: Queue[string]):
        self._binary_queue = binary_queue
        self._text_queue = text_queue

    def on_binary(self, data: bytes):
        self._binary_queue.put(data)

    def on_text(self, data: string):
        self._text_queue.put(data)

class _ReaderFiber(Fiber):
    _tcp_client: TcpClient
    _handler: Handler
    _data_op_code: _OpCode
    _data: bytes

    def __init__(self, handler: Handler, tcp_client: TcpClient):
        self._handler = handler
        self._tcp_client = tcp_client
        self._data = None

    def _read_frame(self) -> (_OpCode, bytes, bool):
        header = self._tcp_client.read(2)
        op_code = _OpCode(header[0] & ~HEADER_MASK)
        fin = (header[0] & HEADER_FIN) == HEADER_FIN
        data_size = u32(header[1] & ~HEADER_MASK)

        if data_size == 126:
            header = self._tcp_client.read(2)
            data_size = (u32(header[0]) << 8 | u32(header[1]))
        elif data_size == 127:
            header = self._tcp_client.read(8)
            data_size = ((u32(header[4]) << 24)
                         | (u32(header[5]) << 16)
                         | (u32(header[6]) << 8)
                         | u32(header[7]))

        data = self._tcp_client.read(data_size)

        return op_code, data, fin

    def _handle_close(self):
        print("Close.")

    def _handle_ping(self):
        print("Ping.")

    def _handle_pong(self):
        print("Pong.")

    def _handle_data(self, op_code: _OpCode, data: bytes, fin: bool):
        if self._data is None:
            self._data_op_code = op_code
            self._data = data
        elif op_code == _OpCode.Continuation:
            self._data += data
        else:
            self._data = None
            return

        if not fin:
            return

        match self._data_op_code:
            case _OpCode.Text:
                self._handler.on_text(string(self._data))
            case _OpCode.Binary:
                self._handler.on_binary(self._data)

        self._data = None

    def run(self):
        while True:
            op_code, data, fin = self._read_frame()

            match op_code:
                case _OpCode.Close:
                    self._handle_close()
                case _OpCode.Ping:
                    self._handle_ping()
                case _OpCode.Pong:
                    self._handle_pong()
                case _:
                    self._handle_data(op_code, data, fin)

class Client:
    """A websocket client, used to communicate with a websocket server.

    """

    _tcp_client: TcpClient
    _reader_fiber: _ReaderFiber
    _binary_queue: Queue[bytes]
    _text_queue: Queue[string]

    def __init__(self, handler: Handler = None):
        """Create a client. Give `handler` as ``None``` to use the default
        handler which puts received messages on message queues that
        are read from with the `receive_binary()` and `receive_text()`
        methods.

        """

        if handler is None:
            # ToDo: Assign to self._binary_queue directly when Mys
            #       supports it.
            binary_queue = Queue[bytes]()
            text_queue = Queue[string]()
            handler = _DefaultHandler(binary_queue, text_queue)
            self._binary_queue = binary_queue
            self._text_queue = text_queue
        else:
            self._binary_queue = None
            self._text_queue = None

        self._tcp_client = TcpClient()
        self._reader_fiber = _ReaderFiber(handler, self._tcp_client)

    def _read_line(self) -> string:
        line = b""

        while True:
            byte = self._tcp_client.read(1)

            if byte is None:
                raise WebsocketError("Handshake failed.")

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    @raises(TcpError, WebsocketError)
    def connect(self, host: string, port: u32, path: string = "/"):
        """Connect to the server identified by given `host` and
        `port`. Non-secure websockets normally use port 80, while
        secure use port 443.

        `path` in the path as sent in the HTTP request to the
        server. For example "/info/299?name=Kalle&date=2021-03-01".

        """

        self._tcp_client.connect(host, port)
        sec_websocket_key = base64_encode(randbytes(16))
        self._tcp_client.write(f"GET {path} HTTP/1.1\r\n"
                               f"Host: {host}\r\n"
                               "Upgrade: WebSocket\r\n"
                               "Connection: Upgrade\r\n"
                               f"Sec-WebSocket-Key: {sec_websocket_key}\r\n"
                               "Origin: MysWebSocketClient\r\n"
                               "Sec-WebSocket-Version: 13\r\n"
                               "\r\n".to_utf8())

        while self._read_line() != "":
            pass

        self._reader_fiber.start()

    def disconnect(self):
        """Disconnect from the server.

        """

        # ToDo: The reader fiber is reading. Should probably cancel
        #       the reader fiber and then perform clean disconnect.

        # self._tcp_client.disconnect()

    def _send(self, data: bytes, op_code: _OpCode):
        header = b""
        data_size = len(data)
        header += (HEADER_FIN | u8(op_code))

        if data_size < 126:
            header += (HEADER_MASK | u8(data_size))
        elif data_size < 65536:
            header += (HEADER_MASK | 126)
            header += u8((data_size >> 8) & 0xff)
            header += u8((data_size >> 0) & 0xff)
        else:
            header += (HEADER_MASK | 127)
            header += 0
            header += 0
            header += 0
            header += 0
            header += ((data_size >> 24) & 0xff)
            header += ((data_size >> 16) & 0xff)
            header += ((data_size >>  8) & 0xff)
            header += ((data_size >>  0) & 0xff)

        header += 0
        header += 0
        header += 0
        header += 0

        self._tcp_client.write(header)
        self._tcp_client.write(data)

    def send_binary(self, data: bytes):
        """Send `data` to the server as a binary message.

        This method never blocks, but instead enqueues the message if
        the OS would block the write.

        """

        self._send(data, _OpCode.Binary)

    def send_text(self, data: string):
        """Send `data` to the server as a text message.

        This method never blocks, but instead enqueues the message if
        the OS would block the write.

        """

        self._send(data.to_utf8(), _OpCode.Text)

    def receive_binary(self) -> bytes:
        """Receive a binary message from the server. This method can only be
        used if no handler was passed to __init__(). Returns ``None``
        if disconnected.

        """

        return self._binary_queue.get()

    def receive_text(self) -> string:
        """Receive a text message from the server. This method can only be
        used if no handler was passed to __init__(). Returns ``None``
        if disconnected.

        """

        return self._text_queue.get()
